/* A literal number including sign and decimal point, also including e notation */
literal         ::= [-+]? [0-9]+ ('.' [0-9]*)? ([eE] [-+]? [0-9]+)?
/* Any string including most UTF8 characters but not exactly '_' */
identifier      ::= '_'? [a-zA-Z#x00F0-#xFFFF] [_a-zA-Z0-9#x00F0-#xFFFF]*
unidentifier    ::= '_'
terminal        ::= ';'
listStart       ::= '('
listEnd         ::= ')'
index           ::= '.' identifier

qualifier       ::= 'intrinsic'
type            ::= ':' identifier index*
port            ::= unidentifier | (identifier type?)
portlist        ::= port (',' port)*

/* Literals can be indexed to call instance functions
   Expression list is optional so that constants/nullary functions don't require redundant parentheses */
expression      ::= ((identifier | literal) (index | (listStart expressionList listEnd))*)
                    | lambda
expressionList  ::= expression (',' expression)*
expressionBody  ::= ('=' expression terminal)

namespace       ::= 'namespace' identifier scope
/* Function ending in a terminal is a function interface */
function        ::= qualifier? declaration type? (body | terminal)
struct          ::= qualifier? 'struct' declaration (scope | terminal)
body            ::= scope | expressionBody
/* Portlist is optional in 2 situations:
       Constant nullary functions where parentheses are redundant
       Declaring interface of intrinsic variadic constructs is impossible (no syntax support for variadics) */
declaration     ::= identifier (listStart portlist listEnd)?
lambda          ::= unidentifier (listStart portlist listEnd) body

element         ::= namespace | struct | function
scope           ::= '{' element* '}'
/* Any complete blob of element code potentially including 1 or many source files */
grammar         ::= element*